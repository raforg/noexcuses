#!/usr/bin/env perl
use 5.006; # and v7
use warnings;
use strict;
BEGIN { pop @INC if $INC[-1] eq '.' }

# noexcuses - runs important cronjobs until they succeed
#
# Copyright (C) 2007-2008, 2020 raf <raf@raf.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <https://www.gnu.org/licenses/>.
#
# 20200625 raf <raf@raf.org>

=head1 NAME

I<noexcuses> - runs important cronjobs until they succeed

=head1 SYNOPSIS

 usage: noexcuses [options] [--] cmd args...
 options:

   -h, --help    - Print the help message then exit
   -V, --version - Print the version message then exit
   -m            - Print the man page then exit
   -r            - Print the man page in nroff format then exit
   -w            - Print the man page in HTML format then exit

   -C configpath - Override the default config file: /etc/noexcuses.conf
   -d period     - Override the default delay between attempts: 1h

 admin options:

   -l         - Print outstanding jobs (mnemonic: list)
   -p         - Run ps on outstanding jobs (mnemonic: processes)
   -x pid|all - Tell outstanding jobs to run now (mnemonic: execute)
   -c pid|all - Cancel outstanding jobs (mnemonic: cancel)
   -A host    - Adopt the given host's jobs from the mirror (mn: adopt)
   -F         - Cancel outstanding jobs that were relocated (mn: forget)
   -M period  - Print cronjobs lost due to downtime (mnemonic: missing)
   -R period  - Run cronjobs lost due to downtime (mnemonic: recover)
   -D         - For -M and -R, print source data for analysis (mn: data)
   -U user    - Change to the given user (root only) (mnemonic: user)
   -H host    - Override the hostname (mnemonic: host)
   -v         - Verbose mode (announce each job with -x -c -A -F -R)
   -q         - Quiet mode (suppress warnings)

=head1 DESCRIPTION

Sometimes cronjobs fail to run successfully because a required server (like
a database or FTP server) is temporarily unavailable due to power failures,
hardware failures, software failures, network outages, choice of operating
system, pilot error, and the like.

Typically, this results in someone being forced to examine crontabs and
error reports, determine which cronjobs really need to be run, and then run
them manually. This happened to me twice in one week. I don't want it to
happen again. Cronjobs are meant to be automated and I want them to stay
that way.

This is the rationale for I<noexcuses>. It keeps track of cronjobs that have
failed and keeps running them until they succeed. All you have to do is look
at your crontabs, identify the cronjobs-that-must-succeed-no-matter-what and
insert I<noexcuses> before the command.

Then, when I<cron> runs I<noexcuses>, I<noexcuses> will run the given
cronjob. If the cronjob fails, I<noexcuses> becomes a daemon that will retry
the cronjob regularly until it succeeds. Even if the cron host is rebooted
before the cronjob succeeds, I<noexcuses> lets you recover (or cancel) all
of the outstanding cronjobs. If you can't wait for the cron host to reboot,
its outstanding cronjobs can be relocated to another cron host and be
forgotten on the original host when it finally reboots.

Also, if the cron host is down for a while, I<noexcuses> can tell you which
cronjobs missed out on running while it was down and run them. The
initscript I<noexcuses.init> can make all these things happen automatically
at boot time.

In other words, I<noexcuses> is a free, lightweight, fine-grained,
unobtrusive, high-availability tool for cronjobs. Or rather, it's a
high-recoverability tool for cronjobs which can either be incorporated into
a highly available system or used in the absence of one.

=head1 OPTIONS

=over 4

=item C<-h>, C<--help>

Print the help message then exit.

=item C<-V>, C<--version>

Print the version message then exit.

=item C<-C> I<configpath>

Override the default config file: C</etc/noexcuses.conf> or
C</usr/local/etc/noexcuses.conf>. See the I<FILES> section below.

=item C<-m>

Print the man page then exit. This is equivalent to executing C<man
noexcuses> but this works even when the man page isn't installed.

=item C<-w>

Print the man page in HTML format then exit. This lets you install the man
page in HTML format with a command like:

 mkdir -p /usr/share/doc/noexcuses/html &&
 noexcuses -w > /usr/share/doc/noexcuses/html/noexcuses.1.html

=item C<-r>

Print the man page in nroff format then exit. This lets you install the man
page with a command like:

 noexcuses -r > /usr/share/man/man1/noexcuses.1

=item C<-q>

Quiet mode. Suppress warnings. Not recommended. Warnings are serious.

=item C<-v>

Verbose mode. Announces each job before executing, cancelling, recovering,
adopting or forgetting them with the C<-x>, C<-c>, C<-R>, C<-A> and C<-F>
options.

=item C<-d> I<period>

Specify the delay between attempts to run the command. The default is C<1h>
(i.e. 1 hour). The I<period> argument looks like:

 [#d][#h][#m][#s]

At least one of the above components must be present. If more than one is
present, they must appear in the order shown above. The final C<"s"> for
seconds is optional. If the given time period is invalid, it is ignored and
the default period of C<1h> is used instead (and a warning is issued).

=item C<-l>

Print any outstanding jobs then exit. You will need to run this as the
C<root> user (and with the C<-U> I<user> option) to see the outstanding jobs
of other users. This enables you to see the pid, owner and command of any
outstanding jobs. A simple way to be notified that jobs are failing (as if
you didn't already know) is to put something like this in your crontab:

 */5 * * * * noexcuses -l

If it produces any output, I<cron> will send it to you in an email. A remote
version is also a good idea.

=item C<-p>

Run I<ps> on any outstanding jobs. You will need to run this as the C<root>
user (and with the C<-U> I<user> option) to run I<ps> on the outstanding
jobs of other users. This only shows process details for outstanding jobs
for which a I<noexcuses> process is currently running. If the C<-p> output
doesn't list a process for every outstanding job listed by the C<-l> option,
then some I<noexcuses> processes are missing and you need to use the C<-x>
option to start them again.

=item C<-x> I<pid|all>

Tell outstanding jobs to try again now. If the option's argument is a pid,
then only the corresponding job is executed. If the option's argument is
C<all>, then all of your outstanding jobs will be executed. You will need to
run this as the C<root> user (and with the C<-U> I<user> option) to execute
the outstanding jobs of other users.

Note that this works even if the I<noexcuses> process referred to by I<pid>
is no longer running (i.e. after a reboot). In this case, it reconstructs
the original call to I<noexcuses> and invokes it.

=item C<-c> I<pid|all>

Cancel outstanding jobs. If the option's argument is a pid, then only the
corresponding job is cancelled (i.e. its I<noexcuses> process is killed and
its state file is removed). If the option's argument is C<all>, then all of
your outstanding jobs will be cancelled. You will need to run this as the
C<root> user (and with the C<-U> I<user> option) to cancel the outstanding
jobs of other users. Note that if a pid is given, and the current process
with that pid doesn't look like the intended I<noexcuses> process, it will
not be killed, as this is a sign that the process was killed by other means,
or that the cron host has been rebooted and the pid now refers to an
unrelated process.

=item C<-A> I<host>

Adopt the given host's jobs from the mirror directory. This will rename all
of the given host's state files in the mirror directory. This is useful when
a primary cron host has gone down, and you want to relocate its outstanding
jobs to a secondary cron host. Both cron hosts must share the mirror
directory. After adopting the primary cron host's outstanding jobs, using
the C<-x> I<all> option will restart them on the secondary cron host. To
start cronjobs that missed out while the primary cron host was down,
identical crontabs must be installed (if they are not already present) and
then the C<-R> option must be used together with the C<-H> option naming the
primary cron host.

Example: Host C<cron1> goes down. Its cronjobs are relocated to host C<cron2>:

On host C<cron2>, adopt host C<cron1>'s outstanding jobs:

 noexcuses -A cron1 -v
 noexcuses -x all -v
 noexcuses -H cron1 -R 1h -v

On host C<cron1>, after it has rebooted:

 noexcuses -F -v
 noexcuses -x all -v
 noexcuses -R 1h -v

=item C<-F>

Cancel outstanding jobs that were relocated to another cron host while the
current cron host was down. Relocated jobs are defined to be those that are
outstanding, but for which there is no corresponding saved state in the
mirror directory. The inference is that another cron host has adopted this
cron host's outstanding jobs. This option cannot be used unless a mirror
directory is configured in C</etc/noexcuses.conf> (or
C</usr/local/etc/noexcuses.conf>). This option can't be used when the mirror
directory is not mounted. If it is, for safety, no jobs are cancelled. The
mirror directory is deemed to be mounted if the log file is present.

=item C<-M> I<period>

Print cronjobs that were lost due to downtime. If the cron host is down
during a period of time in which cronjobs were scheduled to start, those
cronjobs miss out entirely. This option examines your crontab and compares
it against the logfile
C<noexcuses.E<lt>hostnameE<gt>.E<lt>usernameE<gt>.log> to determine which
cronjobs guarded by I<noexcuses> missed out.

You will need to run this as the C<root> user to examine all crontabs on the
cron host. The I<period> argument specifies how far back in time to look for
missing cronjobs. It has the same form as the C<-d> option's I<period>
argument described above. If the given time period is invalid, it is ignored
and the default period of C<12h> is used instead (and a warning is issued).

=item C<-R> I<period>

Run cronjobs that were lost due to downtime. This option is just like the
C<-M> option except that instead of printing the lost cronjobs, it executes
them. Note that it also adds fake log entries to the log file to simulate
the job having run at the correct time. This is to prevent multiple uses of
the C<-R> option from running the same jobs multiple times. When the missing
jobs are run, they will also add an entry to the log file as usual.

You will need to run this as the C<root> user to examine all crontabs on the
cron host. The I<period> argument specifies how far back in time to look for
missing cronjobs. It has the same form as the C<-d> option's I<period>
argument described above. If the given time period is invalid, it is ignored
and the default period of C<12h> is used instead (and a warning is issued).

=item C<-D>

For C<-M> and C<-R>, print source data for analysis. This option can only be
used in conjunction with the C<-M> or C<-R> option. It prints the cronjobs
that were scheduled to execute during the specified time period. It also
prints the log file entries that were produced in the specified time period.
Use this option to verify for yourself that the output of the C<-M> option
is correct before using the C<-R> option. Never use the C<-R> option until
you know exactly what it is going to do and you know that this is the
correct thing for it to do. If it isn't correct, you can run the correct
commands manually but at least I<noexcuses> will have made it easy by
presenting them all to you.

=item C<-U> I<user>

Change to the given user. Used in conjunction with other options, this
option allows the C<root> user to list, cancel and run all of the
outstanding or missing jobs of a particular user rather all users. This is
intended to be used with the administrative options. It can also be used to
launch a cronjob as another user but it's not a good idea. Doing this breaks
the C<-M> and C<-R> options when they are used by the other user or when
they are used by the C<root> user in conjunction with the C<-U> option to
specify that user. The reason is that the cronjob will be logged in the
other user's log file but the cronjob itself is in the C<root> user's
crontab where the other user can't see it. So when the other user uses the
C<-M> or C<-R> option to identify or run their missing jobs, any jobs in the
C<root> user's crontab that are run as that user cannot be examined. If such
jobs are missing, they will not be reported or started. So don't use the
C<-U> option to run new jobs as another user unless the other user has no
intention of using the C<-M> or C<-R> options and the C<root> user has no
intention of using the C<-M> or C<-R> options in conjunction with the C<-U>
option.

=item C<-H> I<host>

Override the hostname. This might be useful when multiple cron hosts share
the same physical directory for their log and state files. When this is the
case and the C<-H> is not used, only the files for the current host are
examined. See the C<spool> parameter in the I<FILES> section. This is
intended to be used with the administrative options but can also be used in
normal usage to lie about what host a job is to run on should the need to do
so arise.

=back

=head1 EXAMPLES

I<noexcuses(1)> is prepended before the real command in crontabs:

 # m h  dom mon dow   command
 0 1 * * * noexcuses cmd arg...
 0 2 * * * noexcuses -d 4h cmd arg...
 0 3 * * * noexcuses -C /home/me/noexcuses.conf cmd arg...

Command names and arguments cannot contain spaces or any other shell
meta-characters.

=head1 FILES

The default configuration files for I<noexcuses> are C</etc/noexcuses.conf>
(or C</usr/local/etc/noexcuses.conf>), and C<~/.noexcusesrc>. This can be
overridden with the C<-C> I<configpath> option. They can contain shell-style
comments (i.e. C<#> to end of the line) and blank lines. They can contain
the following parameters:

 delay = 1h
 spool = /var/noexcuses
 mirror = /nfs/fileserver/noexcuses
 cronpath = /var/spool/cron/crontabs
 pslong = ps -fp
 psfull = ps -fp
 path = /usr/bin:/bin:
 supath = /usr/bin:/bin:

The C<delay> parameter specifies the default delay between attempts to run a
cronjob that has failed.

The C<spool> parameter specifies the directory in which I<noexcuses> stores
its state and log files. This directory must be writable by all users of
I<noexcuses> and it must have the sticky bit set (like C</tmp> and
C</var/tmp> do). This directory must be created in advance by the C<root>
user. If not, the C</var/tmp> directory will be used instead. C</var/tmp>
must exist just in case. I really mean that.

If you override the C<spool> parameter in your own C<~/.noexcusesrc> file,
then your outstanding cronjobs will not be restarted automatically at boot
time but you can still restart them yourself with the C<-x> option. You
should also override the C<mirror> parameter if you override the C<spool>
parameter and the C<mirror> parameter is supplied in C</etc/noexcuses.conf>.

There are also log files in the directory specified by the C<spool>
parameter. This is crucial for the C<-M> and C<-R> options. Don't delete
them after a reboot before you have recovered any lost cronjobs. So using
C</var/tmp> for the C<spool> is a bad idea.

The C<mirror> parameter specifies a separate directory (at least on a
physically separate disk but preferably on a physically separate file
server). This is to help you recover when faced with disk failure. If the
log files, state files and crontabs are stored elsewhere, then the jobs can
be restarted on another host without having to wait for the original cron
host to be repaired or replaced.

The C<cronpath> parameter specifies the directory containing all of the
crontab files.

The C<pslong> parameter specifies the I<ps> command to use that provides the
"long" format needed by the C<-c> and C<-x> options. The default is C<ps -fp>.

The C<psfull> parameter specifies the I<ps> command to use that provides the
"full" format needed by the C<-l> option. The default is C<ps -fp>.

The C<path> and C<supath> parameters specify, for normal users and the super
user respectively, the C<PATH> environment variable to be used when starting
I<noexcuses> processes with the C<-x> and C<-R> options. This should match
the C<PATH> environment variable that I<cron> supplies to your cronjobs.

The configuration file for C</etc/init.d/noexcuses> is
C</etc/default/noexcuses>. It is a shell script that is sourced by
C</etc/init.d/noexcuses>. It can contain the following variables:

 noexcuses # Override the location of the noexcuses command
 period    # Default period between attempts to run a failing job (Default 1h)
 relocated # Forget jobs that were relocated? (i.e. -F) (Default no)
 cancel    # Cancel all known jobs on boot? (i.e. -c all) (Default no)
 restart   # Restart all known jobs on boot? (i.e. -x all) (Default no)
 recover   # Recover missing jobs on boot? (i.e. -R) (Default no)

See the C<RELOCATING CRONJOBS TO ANOTHER CRON HOST> section below for more
information on the C<relocated> variable.

=head1 PERSISTENCE ACROSS REBOOTS

If I<noexcuses> tries to run its cronjob and fails, it saves its state to
disk and then retries the cronjob every now and then until it succeeds. But
the cron host might be rebooted before it succeeds. When this happens, you
can use the C<-x> option to restart all of the outstanding jobs.

Additionally, if any cronjobs guarded by I<noexcuses> were scheduled to
start during the time that the cron host was down, the aforementioned saving
of state to disk will not have taken place because I<cron> didn't get a
chance to start I<noexcuses>. When this happens, you can use the C<-M> and
C<-R> options to run any cronjobs that were scheduled to start during the
time that the cron host was down.

Both of these actions can be automated at boot time by installing
C</etc/init.d/noexcuses> as an initscript and configuring it (in
C</etc/default/noexcuses>) to restart outstanding jobs and recover missing
jobs. By default, C</etc/init.d/noexcuses> does nothing at boot time. See
the I<BUGS> and I<RACE CONDITIONS> sections below for the reason.

=head1 RELOCATING CRONJOBS TO ANOTHER CRON HOST

If your cron host is going to be down for longer than your cronjobs can
afford to wait, you can relocate them to another cron host. The other cron
host needs to have the same software installed in the same places and the
same crontabs (or readily accessible copies) as the original cron host. Most
importantly, the other cron host must have access to the original cron
host's spool or mirror directory and it must use a copy of it as its own
spool directory.

Given all of that, the original cron host's outstanding jobs can be started
up on the other cron host by using I<noexcuses> with the C<-H> and C<-x>
options. And if the other cron host has the original cron host's crontabs
installed, then any jobs that missed out on being run by the original cron
host can be recovered on the other cron host with the C<-H> and C<-R>
options.

When the original cron host comes up again, the C<-F> option can then be
used to make it forget its outstanding jobs that were relocated and
completed successfully on the other cron host. Note that if there were jobs
that had been relocated but that have not yet completed successfully on the
other cron host, they would also be restarted on the original cron host if
the C<-x> option where used on the original cron host, even after the C<-F>
option has been used. If the C<-R> option has been used on the other cron
host, then it should not be used on the original cron host.

In terms of the initscript C</etc/init.d/noexcuses> and its configuration
C</etc/default/noexcuses>, if you use them at all, you can either turn on
(C<restart> and/or C<recovered>) or (C<relocated> and maybe C<cancel>) but
not both.

=head1 IS THIS LIKE ANACRON?

I<Anacron> serves a different purpose to I<noexcuses>. I<Anacron> is for
home computers that aren't always up and where nobody is going to be upset
if their cronjobs don't run when scheduled (otherwise it wouldn't be
expected for the host to be down). What it does is to ensure that too much
time doesn't pass between invocations of periodic jobs assuming that the
host is up occasionally. The success or failure of those jobs is of no more
importance to I<anacron> than it is to I<cron> itself.

I<Noexcuses> is for production systems where the cron host is always up
(unless there's a catastrophe) and cronjobs require access to other hosts
that are always up (unless there's a catastrophe) and there are people
depending on cronjobs being run either when scheduled or as soon as possible
after any catastrophes are resolved. What it does is to ensure that cronjobs
run successfully even in the face of disasters in the machine room.

=head1 WHY IS THERE NO NAME OPTION?

You might be surprised that I<noexcuses> provides no option to name a
cronjob. Naming is usually desired to ensure uniqueness. In other words, a
name option could ensure that, if an attempt to run a named cronjob fails,
then any subsequently cronned instances of identically named cronjobs would
be suppressed until the outstanding job of the same name finally succeeds.
This might seem desirable but it is inappropriate for the sort of cronjobs
that need to be guarded by I<noexcuses>. These jobs are the ones that must
run no matter what. That's why you would use I<noexcuses> with them. If
suppressing cronjobs were acceptable, then it would not make sense to use
I<noexcuses> at all for that cronjob. In fact, if it were acceptable to run
just any one instance of the cronjob, then just letting the cronjob fail
until the problem is resolved (after which it can run successfully) would be
equally acceptable. In other words, if you think that a name option is
needed for a particular cronjob, then that cronjob probably doesn't need
I<noexcuses>. Consider I<daemon> instead which does provide the ability to
name a task and ensure that there is only a single instance of it running at
any one time (L<http://libslack.org/daemon/>).

=head1 CAVEAT

You must make sure that cronjobs that are to run via I<noexcuses> are
written appropriately. Cronjobs that perform a single action using a single
remote server are probably fine. However, cronjobs can get more complicated
than that. A cronjob that requires two remote servers, either or both of
which might fail, should be written so as to not waste time on subsequent
attempts to run, nor should they modify external data multiple times if that
would not be a good thing to do. For example, a cronjob that updates and
queries a remote database, saves the data to disk, and then sends the data
to a remote FTP server has two main points of failure to consider: the
database and the FTP server. The cronjob should be written so that if only
the FTP server fails, the database activity isn't repeated on subsequent
attempts to run the cronjob. At best, it's inefficient. At worst, performing
the database updates multiple times could be a very bad thing indeed. In
other words, all cronjobs should be efficiently idempotent and failsafe. And
of course, they must communicate their failure to their caller,
I<noexcuses>, by exiting with a non-zero exit status.

You need to be wary when the cron host is part of a cluster. There are many
different types of cluster and I can't offer specific instructions on making
I<noexcuses> work in your particular cluster environment except to advise
you to know how your cluster works and to know how I<noexcuses> works and to
make sure that they will work together. For safety in a clustered
environment, it's probably best not to use C</etc/init.d/noexcuses>.
Instead, run I<noexcuses> manually on one of the hosts in the cluster after
a reboot (at least until you can be sure that you know what you are doing).

Also, be aware that I<noexcuses> doesn't know when you have changed your
crontab or what it looked like before. For the purposes of the C<-M> and
C<-R> options, I<noexcuses> assumes that the current crontab has been in
place unchanged for the entire time period specified on the command line.
This would normally be the case. If it is not the case you can get many
false positives. Don't believe them. Even better, don't change your crontabs
before recovering lost jobs after a reboot of the cron host.

=head1 BUGS

The following only applies to the C<-M> and C<-R> options.

Doesn't examine atjobs to look for any jobs that should have started while
the host was down. So don't use I<noexcuses> in atjobs.

Doesn't examine the (Vixie cron) system crontab (C</etc/crontab>) to look
for any jobs that should have started while the host was down. So don't use
I<noexcuses> in C</etc/crontab>. Similarly, C</etc/anacrontab> is ignored.

There is only partial support for Vixie cron syntax extensions. The user
column in C</etc/crontab> isn't supported. Mapping C<%> to return in
commands isn't supported. However, the following extensions are supported:
environment variables, step values (e.g. C<*/5> and C<0-23/2>); day and
month names (first three letters thereof); and the special strings (i.e.
C<@yearly>, C<@annually>, C<@monthly>, C<@weekly>, C<@daily>, C<@midnight>
and C<@hourly> (but not C<@reboot>)).

Doesn't replicate shell parsing of commands. This matters when comparing
crontab entries against the log file entries to identify which scheduled
jobs were not logged as having run. If the command in the crontab doesn't
exactly match a log file entry, I<noexcuses> will think that the job hasn't
run and that it needs to be run. So make sure that your cronjobs are simple
commands. Don't use any shell meta-characters except for a single space
between each argument. In other words:

 cmd arg1 arg2 arg3 # GOOD (no metacharacters)
 cmd arg1 arg2 'arg3' # BAD (quotes)
 cmd arg1  arg2  arg3 # BAD (extra spaces)
 cmd  arg1 'ar g2' arg3 # BAD (quotes, spaces)
 sh -c "cmd \"a b c\" && echo yes || echo no" # BAD (everything)

I cannot guarantee that the C<-R> option will detect every job that missed
out on being run nor that it will not detect any jobs that did run. It works
provided that cron starts jobs within 1 minute of the time for which they
are scheduled and provided there's no disk corruption of the log file and
provided that the cron host doesn't crash at a particularly bad time. See
the I<RACE CONDITIONS> section below to find out when that is. None of that
can be guaranteed. Always check with the C<-M> option first. This will print
a list of commands that the C<-R> option would execute. Use the C<-D> option
as well to verify the list of missing jobs yourself. If the list is wrong,
run the correct commands manually.

In particular, after a cron host crash, determine if a cronjob could have
been running at the time of the crash and somehow verify whether or not it
completed before I<noexcuses> could log it. If you don't, and just run
I<noexcuses> with the C<-R> option, you might end up running a cronjob that
did already complete successfully.

Similarly, after a cron host crash, determine if a cronjob was logged as
having run unsuccessfully at the time of the crash but for which there is no
corresponding state file. If you don't, and just run I<noexcuses> with the
C<-R> or C<-x> option, you might miss out on running a cronjob that has not
yet been run successfully.

Also, after a cron host crash, determine if a cronjob was logged as having
run unsuccessfully before the cron host crash and determine somehow whether
or not it might have just completed successfully at the time of the cron
host crash, before its statefile could be removed. If you don't, and just
run the I<noexcuses> with the C<-x> option, you might end up running a
cronjob that did already complete successfully.

For these reasons, the C</etc/init.d/noexcuses> initscript shouldn't really
be used at all. Recovery after a cron host crash should be done manually
unless you know that no harm will be done if any cronjob runs an extra time
and you know that you can subsequently identify any cronjob that didn't run
and restart those manually. The default behaviour of
C</etc/init.d/noexcuses> is to do nothing at boot time. Resist the
temptation to change that unless the risk is acceptable.

=head1 RACE CONDITIONS

The C<-x> option works by examining the state files (as do the C<-l>, C<-p>
and C<-c> options). The C<-M> and C<-R> options work by examining the log
file and crontabs.

Log entries are written after the first attempt terminates (whether
successfully or not). The state file is written after the first attempt
terminates unsuccessfully. This "ensures" that, in the event of a cron host
crash or reboot, one and only one of the C<-x> and C<-R> options will start
a given cronjob. If the cron host crashes before or during the first
attempt, C<-R> will run it. If the cron host crashes after the first attempt
failed, C<-x> will run it.

However, there are three race conditions. If the cron host crashes after a
cronjob's first attempt terminates successfully but before the log file
entry has been written, then the C<-R> option after rebooting will run the
cronjob even though it terminated successfully. If the cron host crashes
after the first attempt terminates unsuccessfully and after the log file
entry has been written but before the state file is written, then neither
the C<-R> option nor the C<-x> option after rebooting will run the cronjob
even though it did not terminate successfully. If the cron host crashes
after an initially unsuccessful cronjob finally succeeds but before its
state file is removed, then the C<-x> option after rebooting will run the
cronjob even though it terminated successfully. The windows of opportunity
here are very small but they are there nonetheless. Disk corruption of the
log and state files will also ruin your day. So make use of the C<mirror>
parameter in the configuration file.

So I<noexcuses> doesn't really ensure anything but it is a vast improvement
over I<cron> by itself. Even so, please monitor your uninterruptible power
supplies and generators and test them regularly. I really mean that. If
that's too much to ask, then sudden power failures are bound to happen and
might trigger one of the race conditions.

=head1 GOLEM

I wanted to call this program I<golem> because it makes other programs more
determined than they would otherwise be to obey the words in their heads. It
seems to me to be a singularly appropriate name. However, there are already
too many programs out there called I<golem>. And anyway, all software are
golems. This program just makes them better golems. Of all the other names I
thought of, I<noexcuses> seemed to be the most sensible.

=head1 SEE ALSO

I<cron(8)>, I<crontab(1)>, I<crontab(5)>, I<anacron(8)>, I<init(8)>,
I<daemon(1)>

=head1 AUTHOR

20200625 raf <raf@raf.org>

=head1 URL

L<http://raf.org/noexcuses/>,
L<https://github.com/raforg/noexcuses/>
L<https://codeberg.org/raforg/noexcuses/>

=cut

my ($name) = $0 =~ /([^\/]+)$/; # Name of this program
my $version = '1.0'; # Version of this program
my $date = '20200625'; # Date of this version

my $default_config = "/etc/$name.conf"; # System-wide config file
$default_config = "/usr/local$default_config" if -r "/usr/local$default_config"; # In /usr/local/etc?
my $spool = "/var/$name"; # State/log file directory
$spool = "/var/run/$name" if -d "/var/run/$name";
my $cronpath = '/var/spool/cron/crontabs'; # Directory containing all crontabs
my $mirror; # Mirror directory for remote copy state/log files (optional)
my $pslong = 'ps -fp'; # Command to lookup processes for the -x and -c options
my $psfull = 'ps -fp'; # Command to lookup processes for the -l option
my $path = '/usr/bin:/bin:'; # $PATH when starting noexcuses processes
my $supath = $path; # $PATH when starting noexcuses processes for root
my $default_delay = '1h'; # Default delay between attempts to run a job
my $default_gap = '12h'; # Default time period to examine for -M and -R
my $start = time; # When did cron start this process?
my %decoding = (a => "\a", b => "\b", f => "\f", n => "\n", r => "\r", t => "\t");
my %encoding = map { ($decoding{$_}, $_) } keys %decoding;
my %month = qw(jan 1 feb 2 mar 3 apr 4 may 5 jun 6 jul 7 aug 8 sep 9 oct 10 nov 11 dec 12);
my %weekday = qw(sun 0 mon 1 tue 2 wed 3 thu 4 fri 5 sat 6);

sub help
{
	my $msg = shift;
	my $rc = 0;
	$msg = undef, $rc = 1 if ((defined $msg) ? $msg : '') eq '1';

	print $msg, "\n" if defined $msg;
	print
		"usage: $name [options] [--] cmd args...\n",
		"options:\n",
		"\n",
		"  -h, --help    - Print the help message then exit\n",
		"  -V, --version - Print the version message then exit\n",
		"  -m            - Print the man page then exit\n",
		"  -r            - Print the man page in nroff format then exit\n",
		"  -w            - Print the man page in HTML format then exit\n",
		"\n",
		"  -C configpath - Override the default config file: $default_config\n",
		"  -d period     - Override the default delay between attempts: $default_delay\n",
		"\n",
		"admin options:\n",
		"\n",
		"  -l         - Print outstanding jobs (mnemonic: list)\n",
		"  -p         - Run ps on outstanding jobs (mnemonic: processes)\n",
		"  -x pid|all - Tell outstanding jobs to run now (mnemonic: execute)\n",
		"  -c pid|all - Cancel outstanding jobs (mnemonic: cancel)\n",
		"  -A host    - Adopt the given host's jobs from the mirror (mn: adopt)\n",
		"  -F         - Cancel outstanding jobs that were relocated (mn: forget)\n",
		"  -M period  - Print cronjobs lost due to downtime (mnemonic: missing)\n",
		"  -R period  - Run cronjobs lost due to downtime (mnemonic: recover)\n",
		"  -D         - For -M and -R, print source data for analysis (mn: data)\n",
		"  -U user    - Change to the given user (root only) (mnemonic: user)\n",
		"  -H host    - Override the hostname (mnemonic: host)\n",
		"  -v         - Verbose mode (announce each job with -x -c -A -F -R)\n",
		"  -q         - Quiet mode (suppress warnings)\n",
		"\n",
		"See the noexcuses(1) manpage (or noexcuses -m) for more information.\n",
		"\n",
		"Name: $name\n",
		"Version: $version\n",
		"Date: $date\n",
		"Author: raf <raf\@raf.org>\n",
		"URL: http://raf.org/noexcuses/\n",
		"GIT: https://github.com/raforg/noexcuses/\n",
		"GIT: https://codeberg.org/raforg/noexcuses/\n",
		"\n",
		"Copyright (C) 2007-2008, 2020 raf <raf\@raf.org>\n",
		"\n",
		"This is free software released under the terms of the GPLv2+:\n",
		"\n",
		"    https://www.gnu.org/licenses/\n",
		"\n",
		"There is no warranty; not even for merchantability or fitness\n",
		"for a particular purpose.\n",
		"\n",
		"Report bugs to raf <raf\@raf.org>\n";

	exit $rc;
}

sub version
{
	print "$name-$version\n";
	exit;
}

sub man
{
	system "pod2man -r '$name-$version' -s 1 -d '$date' -c 'USER COMMANDS' --quotes=none '$0' | nroff -man | " . ($ENV{PAGER} || 'more');
	exit;
}

sub nroff
{
	system "pod2man -r '$name-$version' -s 1 -d '$date' -c 'USER COMMANDS' --quotes=none '$0'";
	exit;
}

sub html
{
	system "pod2html --title '$name(1)' --noindex '$0'";
	unlink glob 'pod2htm*';
	exit;
}

sub HELP_MESSAGE
{
	help;
}

sub VERSION_MESSAGE
{
	return if $ARGV[0] eq '--help'; # This is called before HELP_MESSAGE for some reason
	version;
}

# Parse the command line

my %opt;
use Getopt::Std;
help 1 unless getopts('hVC:mwrqvd:lpx:c:A:FM:R:DU:H:', \%opt);
help if exists $opt{h};
version if exists $opt{V};
my $config = (exists $opt{C}) ? $opt{C} : $default_config;
man if exists $opt{m};
html if exists $opt{w};
nroff if exists $opt{r};
my $quiet = exists $opt{q};
my $verbose = exists $opt{v};
my $delay = parse_period((exists $opt{d}) ? $opt{d} : $default_delay, $default_delay);
my $debug = exists $opt{D};
use Sys::Hostname;
my $hostname = (exists $opt{H}) ? $opt{H} : hostname; $hostname =~ s/\..*$//;
help("Invalid -H option argument: $hostname (Must contain only alphanumerics and dash)") unless $hostname =~ /^[a-zA-Z0-9-]+$/;
delete $opt{U} if exists $opt{U} && $< && $opt{U} eq (getpwuid $<)[0];
help('The -U option may only be used by root') if exists $opt{U} && $<;
help("Invalid -U option argument: $opt{U} (No such user)") if exists $opt{U} && !defined getpwnam($opt{U});
my ($username, $logpath, $logmirror);
change_user(scalar getpwnam($opt{U})) if exists $opt{U};
init_user();
help('The -l -p -x -c -A -F -M and -R options are mutually exclusive') if (exists $opt{l} ? 1 : 0) + (exists $opt{p} ? 1 : 0) + (exists $opt{x} ? 1 : 0) + (exists $opt{c} ? 1 : 0) + (exists $opt{A} ? 1 : 0) + (exists $opt{F} ? 1 : 0) + (exists $opt{M} ? 1 : 0) + (exists $opt{R} ? 1 : 0) > 1;
help('The -D option requires either the -M or -R option') if exists $opt{D} && !(exists $opt{M} || exists $opt{R});
help('The -A option requires a mirror directory to be configured') if exists $opt{A} && !(defined $mirror && -d $mirror);
help('The -F option requires a mirror directory to be configured') if exists $opt{F} && !(defined $mirror && -d $mirror);
help("Invalid -x option argument: $opt{x} (Must be a pid or \"all\")") if exists $opt{x} && $opt{x} !~ /^(?:\d{1,6}|all)$/i;
help("Invalid -c option argument: $opt{c} (Must be a pid or \"all\")") if exists $opt{c} && $opt{c} !~ /^(?:\d{1,6}|all)$/i;
help("Invalid -A option argument: $opt{A} (Must be the name of a different host)") if exists $opt{A} && $opt{A} eq $hostname;

# Admin commands

list_jobs(), exit if exists $opt{l};
list_processes(), exit if exists $opt{p};
execute_jobs($opt{x}), exit if exists $opt{x};
cancel_jobs($opt{c}), exit if exists $opt{c};
adopt_jobs(), exit if exists $opt{A};
forget_jobs(), exit if exists $opt{F};
missing_jobs($opt{M}), exit if exists $opt{M};
recover_jobs($opt{R}), exit if exists $opt{R};

# Golem command

help('No command supplied') unless @ARGV;
my $logged = 0;
run_job() or daemon();
my $state = save_state();
while (delay()) { run_job() }

sub run_job
{
	my $rc = system @ARGV;
	log_job($rc), ++$logged unless $logged;
	return if $rc;
	unlink $state if defined $state;
	unlink mirror($state) if defined $mirror && defined $state;
	exit;
}

sub log_job
{
	my $rc = shift;
	my $data = "@{[timestamp($start)]} host=$hostname user=@{[(getpwuid $<)[0]]} config=@{[$config]} delay=@{[unparse_period($delay)]} cmd=<<@{[join '>> <<', map { encode($_) } @ARGV]}>> rc=$rc logtime=@{[timestamp()]}\n";
	open my $logfh, '>>', $logpath or warning("Failed to open '$logpath' for append: $!"), return;
	chmod 0600, $logpath or warning("Failed to chmod 0600 $logpath: $!");
	print { $logfh } $data or warning("Failed to write log to $logpath: " . substr($data, 0, -1) . ": $!");
	close $logfh or warning("Failed to close log $logpath: $!");
	mirror_log_job($data) if defined $mirror;
}

sub mirror_log_job
{
	my $data = shift;
	open my $logfh, '>>', $logmirror or warning("Failed to open '$logmirror' for append: $!"), return;
	chmod 0600, $logmirror or warning("Failed to chmod 0600 $logmirror: $!");
	print { $logfh } $data or warning("Failed to write log mirror to $logmirror: " . substr($data, 0, -1) . ": $!");
	close $logfh or warning("Failed to close log mirror $logmirror: $!");
}

sub save_state
{
	use File::Temp; File::Temp->safe_level(File::Temp::HIGH);
	my $fh = eval { File::Temp->new(dir => $spool, template => "$name.$hostname.state.XXXXXX", unlink => 0) };
	$fh = eval { File::Temp->new(dir => $spool, template => "$name.$hostname.state.XXXXXX", unlink => 0) } unless defined $fh;
	File::Temp->safe_level(File::Temp::STANDARD) unless defined $fh;
	$fh = eval { File::Temp->new(dir => $spool, template => "$name.$hostname.state.XXXXXX", unlink => 0) } unless defined $fh;
	my $data = join("\n", 'host ' . $hostname, 'pid ' . $$, 'config ' . $config, 'delay ' . $delay, map("env $_=$ENV{$_}", sort keys %ENV), @ARGV);
	warning("Failed to create state file: $!:\n$data"), return unless defined $fh;
	chmod 0600, $fh->filename or warning('Failed to chmod 0600 ' . $fh->filename . ": $!");
	print { $fh } $data, "\n" or warning('Failed to save state to ' . $fh->filename . ": $!:\n$data");
	close $fh or warning('Failed to close state file: ' . $fh->filename . ": $!:\n$data");
	save_state_mirror(mirror($fh->filename), $data) if defined $mirror;
	return $fh->filename;
}

sub mirror
{
	my $state = shift;
	return $mirror . '/' . substr($state, rindex($state, '/') + 1);
}

sub spool
{
	my $state = shift;
	return $spool . '/' . substr($state, rindex($state, '/') + 1);
}

sub save_state_mirror
{
	my $fpath = shift;
	my $data = shift;
	open my $fh, '>', $fpath or warning("Failed to create state mirror file for: $!:\n$data"), return;
	chmod 0600, $fpath or warning("Failed to chmod 0600 $fpath: $!");
	print { $fh } $data, "\n" or warning("Failed to mirror state to $fpath for: $!:\n$data");
	close $fh or warning("Failed to close state mirror file: $fpath: $!:\n$data");
}

sub delay
{
	my $duration = $delay - (time - $start);
	select(undef, undef, undef, $duration) if $duration > 0;
	$start = time;
}

sub list_jobs
{
	for my $job (all_jobs())
	{
		my $option = ($job->{config} ne $config) ? ' -C ' . $job->{config} : '';
		$option .= ($job->{delay} != $delay) ? ' -d ' . unparse_period($job->{delay}) : '';
		my $owner = ($hostname ne $job->{host} || $< != $job->{uid}) ? "$job->{user}\@$job->{host} " : '';
		print "${owner}pid $job->{pid}: noexcuses$option @{[join(' ', map { join('\\ ', split(/\s+/, $_)) } @{$job->{cmd}})]}\n";
	}
}

sub list_processes
{
	my $hdr = 0;
	for my $job (all_jobs())
	{
		my $env = 'COLUMNS=9999'; # Don't let Linux truncate ps output
		my @ps = split /\n/, `$env $psfull $job->{pid}`;
		print(join("\n", @ps), "\n"), $hdr = 1, next unless $hdr;
		print $ps[1], "\n" if @ps == 2;
	}
}

sub cancel_jobs
{
	my $pid = shift;
	my @jobs = grep { $pid =~ /all/i || $_->{pid} == $pid } all_jobs();
	warning(($pid =~ /all/i) ? 'No outstanding jobs found' : "Pid $pid not found"), return unless @jobs;

	for (grep { is_noexcuses($_->{pid}) } @jobs)
	{
		print("Cancelling: $_->{pid}\n") if $verbose;
		kill 'TERM', $_->{pid} or warning("Failed to terminate process $_->{pid}: $!"), next;
		unlink $_->{path} or warning("Failed to remove $_->{path}: $!");
		unlink mirror($_->{path}) or warning("Failed to remove @{[mirror($_->{path})]}: $!") if defined $mirror;
	}
}

sub execute_jobs
{
	my $pid = shift;
	my @jobs = grep { $pid =~ /all/i || $_->{pid} == $pid } all_jobs();
	warning(($pid =~ /all/i) ? 'No outstanding jobs found' : "Pid $pid not found"), return unless @jobs;
	my $noexcuses_path = noexcuses_path();
	for my $job (@jobs)
	{
		print("Executing: @{$job->{cmd}}\n") if $verbose;
		do { kill 'HUP', $job->{pid} or warning("Failed to signal process $_: $! (giving up!)") }, next if is_noexcuses($job->{pid});
		# It wasn't running, start it again.
		warning("Can't change to user $job->{user} (giving up!)"), next if $< && $job->{uid} != $<;
		my $childpid = fork();
		warning("Failed to fork: $!"), next unless defined $childpid;
		next if $childpid;
		change_user($job->{uid}) if $< == 0 && $job->{uid} != $<;
		unlink $job->{path};
		unlink mirror($job->{path}) if defined $mirror;
		my $home = (getpwuid $job->{uid})[7];
		$home = (-d $home && -x _) ? $home : '/';
		chdir $home or warning("Failed to cd $home: $!");
		$ENV{PATH} = ($<) ? $path : $supath;
		$ENV{$_} = $job->{env}->{$_} for keys %{$job->{env}};
		my @cmd = ($noexcuses_path);
		push(@cmd, '-C', $job->{config}) if $job->{config} ne $default_config;
		push(@cmd, '-d', unparse_period($job->{delay})) if $job->{delay} != parse_period($default_delay);
		push(@cmd, @{$job->{cmd}});
		exec @cmd or print STDERR; # Suppress warning
		exit;
	}
}

sub forget_jobs
{
	warning('Mirror directory doesn\'t look mounted, or nothing mirrored (Aborting)'), return unless glob "$mirror/$name.$hostname.*.log";
	my @relocated_jobs = grep { stat(mirror($_->{path})) ? 0 : 1 } all_jobs();
	warning('No relocated jobs found (Nothing to do)'), return unless @relocated_jobs;
	my @false_positives = grep { is_noexcuses($_->{pid}) } @relocated_jobs;
	warning('There are jobs that seem to be both running locally and relocated (Aborting)'), return if @false_positives;
	if ($verbose) { print("Forgetting: @{$_->{cmd}}\n") for @relocated_jobs };
	unlink $_ or warning("Failed to rm $_: $!") for map { $_->{path} } @relocated_jobs;
}

sub adopt_jobs
{
	my $realhost = $hostname;
	$hostname = $opt{A};
	warning('Mirror directory doesn\'t look mounted, or nothing mirrored (Aborting)'), return unless glob "$mirror/$name.$hostname.*.log";
	my @orphan_jobs = all_jobs($mirror);
	warning('No orphan jobs found (Nothing to do)'), return unless @orphan_jobs;
	adopt_job($_, $realhost) or warning("Failed to adopt $_->{path}: $!") for @orphan_jobs;
}

sub adopt_job
{
	my $oldstate = shift;
	my $newhost = shift;
	my $oldpath = $oldstate->{path};
	my $newpath = $oldpath;
	$newpath =~ s/(\/\Q$name\E\.)(.*)(\.state\..{6})$/$1$newhost$3/;
	print("Adopting: @{$oldstate->{cmd}}\n") if $verbose;
	mv($oldpath, $newpath) or warning("Failed to move $oldpath to $newpath: $!"), return 0;
	cp($newpath, spool($newpath)) or warning("Failed to copy $newpath to @{[spool($newpath)]}: $!"), return 0;
	return 1;
}

sub missing_jobs
{
	my $gap = shift;
	my @missing = find_missing_jobs($gap);
	print "Missing:\n" if $debug;
	print "$_->{time} host $_->{host} user $_->{user} cmd $_->{cmd}\n" for @missing;
	print "\n" if $debug;
}

sub recover_jobs
{
	my $gap = shift;
	my @missing = find_missing_jobs($gap);
	for my $cronned (@missing)
	{
		print("Recovering: $cronned->{cmd}\n") if $verbose;
		my ($uid, $home) = (getpwnam $cronned->{user})[2, 7];
		warning("Can't change to user $cronned->{user} (giving up!)"), next if $< && $uid != $<;
		my $childpid = fork();
		warning("Failed to fork: $!"), next unless defined $childpid;
		next if $childpid;
		change_user($uid) if $< == 0 && $uid != $<;
		$home = (-d $home && -x _) ? $home : '/';
		chdir $home or warning("Failed to cd $home: $!");
		$ENV{PATH} = ($<) ? $path : $supath;
		$ENV{$_} = $cronned->{env}->{$_} for keys %{$cronned->{env}};
		system($cronned->{cmd}) == 0 or warning("Failed to run: $cronned->{cmd} (rc=$?)"), next;
		fake_log_job($cronned, $?);
		exit;
	}
}

sub fake_log_job
{
	my $cronned = shift;
	my $rc = shift;
	my ($delay_arg) = $cronned->{cmd} =~ /\Q$name\E\s+(?:-C\s*\S+\s+)?-d\s*([\ddhms]+)/;
	$delay_arg = unparse_period($delay) unless defined $delay_arg;
	my ($config_arg) = $cronned->{cmd} =~ /\Q$name\E\s+(?:-d\s*[\ddhms]+)?-C\s*(\S+)/;
	$config_arg = $config unless defined $config_arg;
	my $data = "$cronned->{time} host=$cronned->{host} user=$cronned->{user} config=$config_arg delay=$delay_arg cmd=<<@{[join '>> <<', map { encode($_) } split /\s+/, $cronned->{cmd}]}>> rc=$rc logtime=@{[timestamp()]} # recovered\n";
	open my $logfh, '>>', $logpath or warning("Failed to open '$logpath' for append: $!"), return;
	chmod 0600, $logpath or warning("Failed to chmod 0600 $logpath: $!");
	print { $logfh } $data or warning("Failed to write to $logpath: $!");
	close $logfh or warning("Failed to close $logpath: $!");
	mirror_log_job($data) if defined $mirror;
}

sub find_missing_jobs
{
	my $gap = parse_period(shift, $default_gap);
	my $cronned = find_cronned_jobs($gap);
	my $logged = find_logged_jobs($gap);
	return grep { is_missing($_, $logged) } @{$cronned};
}

sub is_missing
{
	my $cronned = shift;
	my $logged = shift;

	for my $log (@{$logged})
	{
		# Override user if -U in command as it logs under that user, not root
		$cronned->{user} = $1 if $< == 0 && $cronned->{cmd} =~ /\Q$name\E(?:\+-d\s*[\ddhms]+)*(?:\s+-U\s*([\w.-]+))/;
		next unless $log->{user} eq $cronned->{user};
		next unless substr($log->{time}, 0, -2) eq substr($cronned->{time}, 0, -2);
		next if $log->{rc} == -1;
		# Cronned cmd contains noexcuses, but logged cmd doesn't, so compare
		# logged cmd with the end of cronned cmd. We should probably check that
		# the config file and delay match but that's probably unnecessary.
		my $cmdstr = join ' ', @{$log->{cmd}};
		next unless $cmdstr eq substr($cronned->{cmd}, -length($cmdstr));
		return 0;
	}

	return 1;
}

sub find_cronned_jobs
{
	my $gap = shift;
	my @crontab = get_crontab();
	my $to = time; $to -= $to % 60;
	my $from = $to - $gap; $from -= $from % 60;
	my @cronned;
	print "Cronned:\n" if $debug;

	for (my $time = $from; $time <= $to; $time += 60)
	{
		my $timestamp = timestamp($time);
		push @cronned,
			map { $debug and print "$timestamp host $_->{host} user $_->{user} cmd $_->{cmd}\n"; $_ }
			map { { time => $timestamp, host => $_->{host}, user => $_->{user}, cmd => $_->{cmd}, env => $_->{env} } }
			grep { cronned_for($time, $_) }
			@crontab;
	}

	print "\n" if $debug;
	return \@cronned;
}

sub cronned_for
{
	my $time = shift;
	my $cronned = shift;
	my ($second, $minute, $hour, $day, $month, $year, $weekday, $doy, $isdst) = localtime $time;
	return exists $cronned->{minute}->{$minute} && exists $cronned->{hour}->{$hour} && (($cronned->{daystar} && exists $cronned->{weekday}->{$weekday}) || ($cronned->{weekdaystar} && exists $cronned->{day}->{$day}) || (!$cronned->{daystar} && !$cronned->{weekdaystar} && (exists $cronned->{day}->{$day} || exists $cronned->{weekday}->{$weekday}))) && exists $cronned->{month}->{$month + 1};
}

sub get_crontab
{
	return parse_crontab('crontab', scalar `cat $cronpath/$username`) if $<;
	my @crontab;
	push @crontab, parse_crontab($_, scalar `cat $_`) for grep { exists $opt{U} ? /\/\Q$opt{U}\E$/ : 1 } glob "$cronpath/*";
	return @crontab;
}

sub parse_crontab
{
	my $fname = shift;
	my $text = shift;
	my ($user) = $fname =~ /\/([^\/]+)$/;
	$user = (getpwuid $<)[0] unless defined $user;
	my $line = 0;
	my @tab;
	my $env = {};

	for (split /\n/, $text)
	{
		++$line;
		next if /^#/; next if /^$/;
		$env->{$1} = $2, next if /^\s*([_a-zA-Z][_a-zA-Z0-9]*)\s*=\s*(.+)\s*$/;
		push @tab, parse_cronline($user, $fname, $line, $_, { %{$env} });
	}

	return @tab;
}

sub parse_cronline
{
	my $user = shift;
	my $fname = shift;
	my $line = shift;
	my $text = shift;
	my $env = shift;
	warning("Ignoring invalid environment variable in $fname line $line: $text"), return () if $text =~ /^\s*\S+\s*=/;
	warning("Ignoring \@reboot directive in $fname line $line: $text"), return () if $text =~ /^\s*\@reboot/i;
	$text =~ s/^\s*\@(?:yearly|annually)/0 0 1 1 */i;
	$text =~ s/^\s*\@monthly/0 0 1 * */i;
	$text =~ s/^\s*\@weekly/0 0 * * 0/i;
	$text =~ s/^\s*\@(?:daily|midnight)/0 0 * * */i;
	$text =~ s/^\s*\@hourly/0 * * * */i;
	my ($minute, $hour, $day, $month, $weekday, $cmd) = $text =~ /([*\d,\/-]+)\s+([*\d,\/-]+)\s+([*\d,\/-]+)\s+([*\d,\/-]+|@{[join '|', keys %month]})\s+([*\d,\/-]+|@{[join '|', keys %weekday]})\s+(.*)\s*$/i;
	warning("Syntax error in crontab $fname line $line: $text"), return () unless defined $cmd;
	$month = $month{lc $month} if exists $month{lc $month};
	$weekday = $weekday{lc $weekday} if exists $weekday{lc $weekday};
	return () unless $cmd =~ /\Q$name\E/; # Ignore jobs not guarded by noexcuses
	return () if $cmd =~ /\Q$name\E\s+(-[qv]+\s+|-[qv]*[dUHC]\s*\S+\s+)*-[hVmwrlpkxMRD]/; # Ignore noexcuses -l commands
	warning("Cronjob in $fname contains shell meta-characters: $cmd") if $cmd =~ /[|&;()<>\[\]{}\$\`'~\"\\*?\t\r\n]/;
	return
	{
		host => $hostname,
		user => $user,
		minute => expand_cronspec($minute, 0, 59),
		hour => expand_cronspec($hour, 0, 23),
		day => expand_cronspec($day, 1, 31),
		daystar => ($day eq '*' ? 1 : 0),
		month => expand_cronspec($month, 1, 12),
		weekday => expand_cronspec($weekday, 0, 6, 7),
		weekdaystar => ($weekday eq '*' ? 1 : 0),
		cmd => $cmd,
		env => $env
	};
}

sub expand_cronspec
{
	my $spec = shift;
	my $min = shift;
	my $max = shift;
	my $zero = shift;
	$spec =~ s/(\d+)-(\d+)\/(\d+)/expand_cronstep($1, $2, $3)/eg;
	$spec =~ s/\*\/(\d+)/expand_cronstep($min, $max, $1)/eg;
	$spec =~ s/(\d+)-(\d+)/join(',', $1..$2)/eg;
	$spec =~ s/^(\d+)\/\d$/$1/; # Vixie cron silently does this too
	$spec =~ s/\*/join(',', $min..$max)/eg;
	return { map { ($zero && $_ == $zero ? 0 : $_, 1) } split /,/, $spec };
}

sub expand_cronstep
{
	my $start = shift;
	my $end = shift;
	my $step = shift;
	my @values;

	while ($start <= $end)
	{
		push @values, $start;
		$start += $step;
	}

	return join ',', @values;
}

sub find_logged_jobs
{
	my $gap = shift;
	my $to = time; $to -= $to % 60;
	my $from = $to - $gap; $from -= $from % 60;
	my @logged;
	my $since = timestamp($from);
	my $logglob = "$name.$hostname.@{[($<) ? $username : (exists $opt{U}) ? $opt{U} : '*']}.log";

	my @logfiles = grep { -f && -r _ && (!$< || -o _) } glob "$spool/$logglob";
	push @logfiles, grep { -f && -r _ && (!$< || -o _) } glob "$mirror/$logglob" if defined $mirror;

	for my $log (@logfiles)
	{
		print "Logged $log:\n" if $debug;
		open my $logfh, '<', $log or warning("Failed to open '$log': $!"), next;
		my $line = 0;

		while (<$logfh>)
		{
			++$line; s/[\r\n]+$//;
			my ($time, $host, $user, $config, $delay, $cmd, $rc, $logtime, $note) = $_ =~ /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) host=(\S+) user=(\S+) config=(.*?) delay=([\ddhms]+) cmd=<<(.*?)>> rc=(-?\d+) logtime=(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})( # .+)?$/;
			warning("Invalid log file entry in $log line $line: $_"), next unless defined $cmd;
			next unless ($time cmp $since) >= 0;
			push @logged, { time => $time, host => $host, user => $user, config => $config, delay => parse_period($delay), cmd => [map { decode($_) } split />> <</, $cmd], rc => $rc, logtime => $logtime, note => $note };
			print "$time host $host user $user config $config delay $delay cmd @{[join ' ', @{$logged[$#logged]->{cmd}}]} rc $rc logtime $logtime@{[defined $note ? $note : '']}\n" if $debug;
		}

		close $logfh;
		print "\n" if $debug;
	}

	return \@logged;
}

sub noexcuses_path
{
	my $noexcuses_path = $0;
	return $noexcuses_path if $noexcuses_path =~ /^\//;
	return POSIX::getcwd() . '/' . substr($noexcuses_path, 2) if $noexcuses_path =~ /^\.\//;
	return POSIX::getcwd() . '/' . $noexcuses_path if $noexcuses_path !~ /\//;
	return $noexcuses_path;
}

sub is_noexcuses
{
	my $pid = shift;
	my $env = 'COLUMNS=9999'; # Don't let Linux truncate ps output
	my @ps = split /\n/, `$env $pslong $pid`;
	my $shortname = substr $name, 0, 6; # Solaris truncates names
	return (@ps == 2 && $ps[1] =~ /\Q$shortname\E/) ? 1 : 0;
}

sub all_jobs
{
	my $dir = shift || $spool;
	my @jobs;

	for my $state (glob "$dir/$name.$hostname.state.?????? /var/tmp/$name.$hostname.state.??????")
	{
		my @stat = stat($state) or warning("Failed to stat '$state': $!"), next;
		next if $< && $< != $stat[4];
		my $s = parse_state($state, $stat[4]) or next;
		next if exists $opt{U} && $s->{user} ne $opt{U};
		push @jobs, $s;
	}

	# Sort by user, then cmd (for test automation)
	return sort { $a->{user} cmp $b->{user} || join("\0\0\0", @{$a->{cmd}}) cmp join("\0\0\0", @{$b->{cmd}}) } @jobs;
}

sub parse_state
{
	my $fname = shift;
	my $uid = shift;
	open my $statefh, '<', $fname or warning("Failed to open '$fname' for reading: $!"), return;
	my $host = <$statefh>;
	warning("Failed to parse '$fname': Invalid host line: $host"), close($statefh), return unless defined $host && $host =~ /^host ([a-z0-9.-]+)$/;
	$host = $1;
	my $pid = <$statefh>;
	warning("Failed to parse '$fname': Invalid pid line: $pid"), close($statefh), return unless defined $pid && $pid =~ /^pid ([0-9]+)$/;
	$pid = $1;
	my $config = <$statefh>;
	warning("Failed to parse '$fname': Invalid config line: $config"), close($statefh), return unless defined $config && $config =~ /^config (.+)$/;
	$config = $1;
	my $delay = <$statefh>;
	warning("Failed to parse '$fname': Invalid delay line: $delay"), close($statefh), return unless defined $delay && $delay =~ /^delay ([0-9]+)$/;
	$delay = $1;
	my @cmd;
	my $env = {};

	while (defined($_ = <$statefh>))
	{
		s/[\r\n]+//;
		$env->{$1} = $2, next if /^env ([_a-zA-Z][_a-zA-Z0-9]*)=(.*)$/;
		push @cmd, $_;
	}

	close $statefh;
	warning("Failed to parse '$fname': Command missing"), return unless @cmd;
	return { path => $fname, uid => $uid, host => $host, user => (getpwuid $uid)[0], pid => $pid, config => $config, delay => $delay, cmd => [@cmd], env => $env };
}

sub parse_config
{
	my $cfg = shift;
	open my $cfgfh, '<', $cfg or return;

	while (<$cfgfh>)
	{
		s/#.*$//, s/\s+$//, s/^\s+//, s/\s+/ /g;
		next unless length;
		$delay = parse_period($1) if /^delay\s*=\s*(.*)$/i;
		$spool = $1 if /^spool\s*=\s*(.*)$/i;
		$mirror = $1 if /^mirror\s*=\s*(.*)$/i;
		$cronpath = $1 if /^cronpath\s*=\s*(.*)$/i;
		$pslong = $1 if /^pslong\s*=\s*(.*)$/i;
		$psfull = $1 if /^psfull\s*=\s*(.*)$/i;
		$path = $1 if /^path\s*=\s*(.*)$/i;
		$supath = $1 if /^supath\s*=\s*(.*)$/i;
	}

	close $cfgfh;
}

sub parse_period
{
	my $period = shift;
	my $default_period = shift;
	my $save = $period;
	my $seconds = 0;
	$seconds += 86400 * $1, $period =~ s/^\d+d//i if $period =~ /^(\d+)d/i;
	$seconds += 3600 * $1, $period =~ s/^\d+h//i if $period =~ /^(\d+)h/i;
	$seconds += 60 * $1, $period =~ s/^\d+m//i if $period =~ /^(\d+)m/i;
	$seconds += $1, $period =~ s/^\d+s?//i if $period =~ /^(\d+)s?/i;
	return $seconds if $seconds && $period eq '';
	warning("Invalid time period for delay: '$save' (continuing with default: $default_period)");
	return parse_period($default_period, $default_period);
}

sub unparse_period
{
	my $seconds = int shift;
	my $days = int($seconds / 86400); $seconds -= $days * 86400;
	my $hours = int($seconds / 3600); $seconds -= $hours * 3600;
	my $minutes = int($seconds / 60); $seconds -= $minutes * 60;
	my $duration = "${days}d${hours}h${minutes}m${seconds}s";
	$duration =~ s/^0d//, $duration =~ s/^0h//, $duration =~ s/^0m//;
	$duration =~ s/m0s$/m/, $duration =~ s/h0m$/h/, $duration =~ s/d0h$/d/;
	return $duration;
}

sub change_user
{
	my $uid = shift;
	my $gid = (getpwuid $uid)[3];
	$( = $) = "$gid $gid";
	$< = $> = $uid;
	die "Failed to change to user $uid: uid=$< euid=$>\n" unless $< eq $uid && $> eq $uid;
	warning("Failed to completely set groups for user @{[(getpwuid $uid)[0]]}: gid=$( egid=$)") unless $( eq "$gid $gid" && $) eq "$gid $gid";
}

sub init_user
{
	parse_config($config);
	parse_config((getpwuid $<)[7] . "/.${name}rc");
	$username = (getpwuid $<)[0];
	$logpath = "$spool/$name.$hostname.$username.log";
	$logmirror = mirror($logpath) if defined $mirror;
}

sub daemon
{
	my $pid = fork; # Background process to lose session/group leadership
	warning("Failed to fork: $! (continuing)"), return unless defined $pid;
	exit if $pid;
	use POSIX; POSIX::setsid; # Become a process session leader
	chdir '/'; # Change to the root directory to prevent hampering umounts
	umask 0; # Clear umask to enable explicit file modes
	close STDIN; # Point stdin, stdout and stderr to /dev/null just in case
	close STDOUT;
	close STDERR;
	open STDIN, '<', '/dev/null';
	open STDOUT, '>', '/dev/null';
	open STDERR, '>', '/dev/null';
	$SIG{HUP} = sub {};
}

sub encode
{
	my $str = shift;
	$str =~ s/(@{[join '|', keys %encoding]})/$encoding{$1}/eg;
	return $str;
}

sub decode
{
	my $str = shift;
	$str =~ s/\\(@{[join '|', keys %decoding]})/$decoding{$1}/eg;
	$str =~ s/\\(.)/$1/g;
	return $str;
}

sub timestamp
{
	my $time = shift || time;
	use POSIX; return POSIX::strftime '%Y-%m-%d %H:%M:%S', localtime($time);
}

sub warning
{
	my $msg = shift;
	warn "$name: $msg\n" unless $quiet;
}

sub mv
{
	my $src = shift;
	my $dst = shift;
	if (-d $dst) { my ($fn) = $src =~ /([^\/]+)\/?$/; $dst .= "/$fn" }
	return (link($src, $dst) || copy_file($src, $dst)) && unlink($src);
}

sub cp
{
	my $src = shift;
	my $dst = shift;
	if (-d $dst) { my ($fn) = $src =~ /([^\/]+)\/?$/; $dst .= "/$fn" }
	return copy_file($src, $dst);
}

sub copy_file
{
	my $src = shift;
	my $dst = shift;
	my $kb = shift || 32;

	open my $srcfh, '<', $src or return 0;
	open my $dstfh, '>', $dst or close($srcfh), return 0;
	chmod 0600, $dst or warning("Failed to chmod 0600 $dst: $!");
	my $buf;

	while (my $bytes_read = sysread($srcfh, $buf, $kb * 1024))
	{
		close($srcfh), close($dstfh), unlink($dst), return 0
			unless defined $bytes_read;
		last if $bytes_read == 0;
		my $bytes_written = syswrite($dstfh, $buf, $bytes_read);
		close($srcfh), close($dstfh), unlink($dst), return 0
			unless defined $bytes_written && $bytes_written == $bytes_read;
	}

	close $srcfh;
	close $dstfh;
	return 1;
}

# vi:set ts=4 sw=4:
